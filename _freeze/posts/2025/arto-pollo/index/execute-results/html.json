{
  "hash": "dc76905ca377f12f653bcf5db75486a1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"aRt-o Pollo\"\nsubtitle: \"\"\ncategories: [R,  art,  2025]\ndate: \"2025-02-21\"\nformat: \n  html:\n    include-in-header:\n    - text: |\n            <style>\n              .quarto-figure {\n                margin: 0;\n              }\n            </style>\nerror: true\ncache: false\n---\n\n\n\n\n\nImagine a universe where light behaves differently than ours. Rather than diffusing its intensity with distance, and simply increasing it with multiple sources, light in this universe is different. When two light beams meet, their combined intensity depends on the angle between them. Right angles are the best - when two light beams meet at a point perpendicularly, they have the highest possible intensity at that point. As the angle becomes smaller or bigger than 90 degrees (pi/2 radians), the intensity becomes weaker.\n\nWhy would you imagine such a thing? I don't know why I wonder about such things, but I often do. As an example, I drew the image below while thinking about this - we have two \"suns\", the red dots are 90 degree intersections, the blue points are intersections with a smaller angle.\n\n![](two-source-rays.png)\n\nDrawing can only get me so far, but this is an easy enough simulation to do in R, and the results are pretty, especially when we change some of those initial assumptions. I've long been a fan of Danielle Navarro's [approach to generative art](https://art-from-code.netlify.app/), and it has been years since I dipped my toes in these waters, so here goes nothing. This post will be light on details, but hopefully it makes sense. Let's explore how this imaginary physics creates some beautiful patterns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(purrr)\nlibrary(patchwork)\nlibrary(ambient)\nlibrary(wesanderson)\nlibrary(httpgd)\nlibrary(ggdark)\nlibrary(viridis)\nlibrary(fields)\nset.seed(12345)\n\ntheme_set(\n  dark_theme_void() +\n    theme(plot.background = element_rect(fill = \"#1F1F1F\", color = \"#1F1F1F\"))\n)\n```\n:::\n\n\n\nWhat things do we need for the simplest possible simulation?\n\n- two fixed points A and B for our light sources\n- a way to calculate the angle formed at any other point X where beams from A and B intersect - a way to convert this angle into an intensity value \n- calculate the intensity for many different points in the plane \n- visualize the result\n\nHere are some basic functions to do this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Calculates the angle formed by AX and BX\n#'\n#' @param X a numeric vector of length 2 or a matrix with two columns in which each row represents the x and y coordinates of a point\n#' @param A A numeric vector of length 2 representing the first source\n#' @param B A numeric vector of length 2 representing the second source\n#' @return The angle in radians between vectors A and B with respect to point(s) X.\nangle <- function(X, A, B) {\n  X <- as.matrix(X)\n  if (length(X) == 2) X <- t(X)\n  A <- rep(A, each = length(X)/2)\n  B <- rep(B, each = length(X)/2)\n\n  v1 <- X - A\n  v2 <- X - B\n  dot_product <- rowSums(v1 * v2)\n  norm <- sqrt(rowSums(v1 * v1)) * sqrt(rowSums(v2 * v2))\n  cos_theta <- dot_product / norm\n  acos(cos_theta)\n}\n\n#' Convert angle to intensity\n#'\n#' @param theta A numeric value representing the angle in radians.\n#' @return A numeric value representing the intensity.\nangle_to_intensity <- function(theta) {\n  1 - abs(theta - pi / 2) / (pi / 2)\n}\n\n\n#' Calculate intensity at a point\n#' \n#' @param x a numeric vector of length 2 or a matrix with two columns in which each row represents the x and y coordinates of a point\n#' @param source1 A numeric vector of length 2 representing the first source\n#' @param source2 A numeric vector of length 2 representing the second source\n#' @param angle_transform_fun A function that takes an angle in radians and returns\n#'  a value to be plotted as the coordinate intensity. Default is a linear function of \n#'  the absolute deviation from a right angle.\n#' @return A numeric value in [0, 1] representing the intensity at point x.\nintensity <- function(x, source1, source2, angle_transform_fun = angle_to_intensity) {\n  theta <- angle(x, source1, source2)\n  angle_transform_fun(theta)\n}\n```\n:::\n\n\n\nWith these functions in hand we can play around. We need two sources:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nA <- c(-1, 0)\nB <- c(1, 0)\n```\n:::\n\n\n\nJust as an illustration, the maximum intensity should be at point (0, 1) which forms a right angle. The minimum intensity should be at any point on the AB line, e.g. (0, 0) as it forms a 180 degree angle:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nintensity(c(0, 1), A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nintensity(c(0, 0), A, B)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n\nNow we need a grid of points where their beams will intersect:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid <- expand.grid(\n  x = seq(-2, 2, 0.01),\n  y = seq(-2, 2, 0.01)\n)\n```\n:::\n\n\n\nand evaluate their intensity:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid$intensity1 <- intensity(grid[c(\"x\", \"y\")], A, B)\n\nmain_plot <- grid |> \n  ggplot(aes(x, y, fill = intensity1, color = intensity1)) +\n  geom_raster()\n  \nmain_plot + scale_fill_gradientn(colors = viridis::inferno(256))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){fig-align='center' width=576}\n:::\n:::\n\n\n\nThat's kinda cool. Mostly what I expected, but it's pretty. We can try a few more color schemes and plot settings. To make things a bit easier, I want to simultaneously plot multiple versions with different binning granularities:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot3s <- function(main, pallette) {\n  p1 <- main + \n    scale_fill_stepsn(colors = pallette, n.breaks = 12) + \n    theme(legend.position = \"none\")\n  p2 <- main + \n    scale_fill_stepsn(colors = pallette, n.breaks = 24) + \n    theme(legend.position = \"none\")\n  p3 <- main + \n    scale_fill_gradientn(colors = pallette) + \n    theme(legend.position = \"none\")\n\n  p1 + p2 + p3\n}\n```\n:::\n\n\n\nFor example with out original palette we get:\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nplot3s(main_plot, viridis::inferno(256))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=1440}\n:::\n:::\n\n\n\nWith the binned version on the left, I notice something that wasn't as obvious in the smooth one: there is more than one circle! In fact, all points that form the same angle with A and B lie on a circle. This wasn't immediately obvious to me, but I eventually remembered the [inscribed angle theorem](https://www.wikiwand.com/en/articles/Inscribed_angle) from high school geometry. This theorem is a more general case of the well-known Thales' theorem, which states that all points on a circle form 90-degree angles with any diameter line of the circle. The resulting figure also represents one half of what is known as the [Apollonian circles](https://www.wikiwand.com/en/articles/Apollonian_circles). This realization led me down a Wikipedia rabbit hole, where I read more about alternative coordinate systems like the [bipolar coordinate system](https://www.wikiwand.com/en/articles/Bipolar_coordinates). At first glance, it seems esoteric and pointless, but it turns out it can [simplify many problems](https://arc.net/l/quote/jfwaoyhl) that are otherwise too complicated to compute in standard Cartesian coordinate systems.\n\nAnyway, let's go on with making pretty variations on this theme.\n\n\n\n::: {.cell .column-page layout-align=\"ce#| nter\"}\n\n```{.r .cell-code}\nplot3s(main_plot, hcl.colors(12, \"YlOrRd\", rev = TRUE))\nplot3s(main_plot, c(\"#00FFFF\", \"#8A2BE2\", \"#FFD700\"))\nplot3s(main_plot, wes_palette(\"Royal1\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='ce#| nter' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){fig-align='ce#| nter' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-3.png){fig-align='ce#| nter' width=1440}\n:::\n:::\n\n\n\nAlright, how about we add some correlated noise for variety?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngaussian_kernel <- function(sigma_x, sigma_y = sigma_x) {\n  size_x <- ceiling(2 * sigma_x) + 1\n  size_y <- ceiling(2 * sigma_y) + 1\n  \n  kernel <- outer(-size_x:size_x, -size_y:size_y, function(x, y) {\n    exp(-(x^2 / (2 * sigma_x^2) + y^2 / (2 * sigma_y^2)))\n  })\n\n  kernel / sum(kernel)\n}\n\nconvolve2d <- function(mat, kernel) {\n  fft_mat <- fft(mat)\n  fft_kernel <- fft(kernel, dim(mat))\n  Re(fft(fft_mat * fft_kernel, inverse = TRUE) / length(mat))\n}\n\nsmooth_matrix <- function(mat, kernel = gaussian_kernel(1)) {\n  pad_kernel <- matrix(0, nrow = nrow(mat), ncol = ncol(mat))\n  pad_kernel[1:nrow(kernel), 1:ncol(kernel)] <- kernel\n  convolve2d(mat, pad_kernel)\n}\n\ngrid_size <- sqrt(nrow(grid))\nnoise <- matrix(rnorm(grid_size^2), grid_size)\nnoise <- smooth_matrix(noise, kernel = gaussian_kernel(10))\n```\n:::\n\n\n\nNow won't you look at that!\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\ngrid$intensity2 <- grid$intensity1 + as.vector(t(noise))\n\nnoise_plot <- grid |> \n  ggplot(aes(x, y, fill = intensity2, color = intensity2)) +\n  geom_raster() +\n  theme(legend.position = \"none\")\n\nplot3s(noise_plot, rev(viridis::inferno(256)))\nplot3s(noise_plot, hcl.colors(12, \"YlOrRd\", rev = TRUE))\nplot3s(noise_plot, c(\"#00FFFF\", \"#8A2BE2\", \"#FFD700\"))\nplot3s(noise_plot, wes_palette(\"Royal1\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-2.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-3.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-4.png){fig-align='center' width=1440}\n:::\n:::\n\n\n\nAlright, one last one. Instead of clamping the intensity to be a linear function of how much the angle deviates from 90 degrees, let's introduce some oscillations. We'll also use a larger range of x and y coordinates.\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\nnonlinear_intensity <- function(theta) {\n  deviation <- abs(theta - pi/2) / (pi/2)\n  sin(2 * pi * deviation)^2\n}\n\nbigger_grid <- expand.grid(\n  x = seq(-4, 4, 0.02),\n  y = seq(-4, 4, 0.02)\n)\n\nbigger_grid_size <- sqrt(nrow(bigger_grid)) \nbigger_noise <- matrix(rnorm(bigger_grid_size^2, sd = 2), bigger_grid_size)\nbigger_noise <- smooth_matrix(bigger_noise, kernel = gaussian_kernel(10))\n\nbigger_grid$intensity3 <- intensity(bigger_grid[c(1,2)], A, B, nonlinear_intensity) + \n  as.vector(t(bigger_noise))\n\nnoise_plot_nl <- bigger_grid |> \n  ggplot(aes(y, x, fill = intensity3, color = intensity3)) +\n  geom_raster() +\n  theme(legend.position = \"none\")\n\nplot3s(noise_plot_nl, viridis::inferno(256))\nplot3s(noise_plot_nl, hcl.colors(12, \"YlOrRd\", rev = TRUE))\nplot3s(noise_plot_nl, c(\"#00FFFF\", \"#8A2BE2\", \"#FFD700\"))\nplot3s(noise_plot_nl, grey.colors(2))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-2.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-3.png){fig-align='center' width=1440}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-4.png){fig-align='center' width=1440}\n:::\n:::\n\n\n\nLast one, for real this time:\n\n\n\n::: {.cell .column-page layout-align=\"center\"}\n\n```{.r .cell-code}\n# Generate and smooth directional noise\ngrid_size <- sqrt(nrow(grid))\nnoise_matrix <- matrix(rnorm(grid_size^2), nrow = grid_size)\nsmoothed_noise <- smooth_matrix(noise_matrix, kernel = gaussian_kernel(sigma_x = 10, sigma_y = 2))\n\n# Apply noise only on the bottom part of the image and clip intensity between 0 and 1\nis_lower_half <- grid$y < 0\ngrid$intensity4 <- ifelse(\n  is_lower_half,\n  grid$intensity1^0.75 + as.vector(smoothed_noise),\n  grid$intensity1\n) \n\n# somewhat random aesthetic choices\ninside_upper_circle <- (grid$y^2 + grid$x^2 <= 1) & !is_lower_half\ngrid$intensity4 <- pmax(pmin(grid$intensity4, 1), 0)\ngrid$intensity4[inside_upper_circle] <- grid$intensity4[inside_upper_circle]^0.4\n\nstreak_noise_plot <- grid |> \n  ggplot(aes(x, y, fill = intensity4, color = intensity4)) +\n  geom_raster() +\n  theme(legend.position = \"none\")\n\nplot3s(streak_noise_plot, viridis::inferno(256))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=1440}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}